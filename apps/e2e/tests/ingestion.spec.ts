import { test, expect } from '@playwright/test';
import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';

test.describe('Document Ingestion', () => {
  test('should upload and ingest a markdown file successfully', async ({ page }) => {
    // 1. Navigate to home
    await page.goto('/');
    await expect(page).toHaveTitle(/Qurio/);

    // 2. Click File Upload Tab
    await page.getByRole('button', { name: 'File Upload' }).click();
    await expect(page.getByText('Select Document')).toBeVisible();

    // 3. Upload File
    // Create a virtual file for the test
    const fileContent = '# Automated Test Doc\n\nThis is a test document created by Playwright e2e tests.\n';
    await page.setInputFiles('input[type="file"]', {
      name: 'e2e-test.md',
      mimeType: 'text/markdown',
      buffer: Buffer.from(fileContent)
    });

    // 4. Click Upload & Ingest
    const uploadBtn = page.getByRole('button', { name: 'Upload & Ingest' });
    await expect(uploadBtn).toBeEnabled();
    await uploadBtn.click();

    // 5. Verify Status Transition
    // It might start as pending/in_progress, wait for completed
    // We look for a badge within a card that contains our filename
    const sourceCard = page.locator('.rounded-xl', { hasText: 'e2e-test.md' }).first();
    
    // Wait for the status badge to say 'completed'
    // Increase timeout because ingestion might take a moment
    await expect(sourceCard).toContainText('completed', { timeout: 30000 });

    // 6. Verify Details Page
    await sourceCard.getByRole('button', { name: 'View Details' }).click();
    
    // Verify we are on details page
    await expect(page.getByRole('heading', { name: 'Source Details' })).toBeVisible();
    // Use more specific locator to avoid strict mode violation (matches both header and chunk list)
    await expect(page.locator('h1:has-text("Source Details") + p:has-text("e2e-test.md")')).toBeVisible();
    
    // Verify chunks content matches what we uploaded
    await expect(page.getByText('# Automated Test Doc')).toBeVisible();
  });

  test('should upload and ingest a PDF file successfully', async ({ page }) => {
    // 1. Generate Valid PDF
    const pdfDoc = await PDFDocument.create();
    const timesRomanFont = await pdfDoc.embedFont(StandardFonts.TimesRoman);
    const page1 = pdfDoc.addPage();
    const { width, height } = page1.getSize();
    page1.drawText('This is a test PDF generated by Playwright.', {
      x: 50,
      y: height - 4 * 50,
      size: 30,
      font: timesRomanFont,
      color: rgb(0, 0.53, 0.71),
    });
    const pdfBytes = await pdfDoc.save();

    // 2. Navigate to home
    await page.goto('/');

    // 3. Click File Upload Tab
    await page.getByRole('button', { name: 'File Upload' }).click();

    // 4. Upload File
    await page.setInputFiles('input[type="file"]', {
      name: 'e2e-test.pdf',
      mimeType: 'application/pdf',
      buffer: Buffer.from(pdfBytes)
    });

    // 5. Click Upload & Ingest
    const uploadBtn = page.getByRole('button', { name: 'Upload & Ingest' });
    await expect(uploadBtn).toBeEnabled();
    await uploadBtn.click();

    // 6. Verify Status Transition
    const sourceCard = page.locator('.rounded-xl', { hasText: 'e2e-test.pdf' }).first();
    await expect(sourceCard).toContainText('completed', { timeout: 90000 }); // Longer timeout for PDF processing

    // 7. Verify Details Page
    await sourceCard.getByRole('button', { name: 'View Details' }).click();
    
    // Verify chunk content (Docling should extract the text)
    await expect(page.getByText('This is a test PDF generated by Playwright')).toBeVisible({ timeout: 10000 });
  });

  test('re-ingestion should replace chunks (idempotency)', async ({ page }) => {
    // 1. Ingest a file
    await page.goto('/');
    await page.getByRole('button', { name: 'File Upload' }).click();
    
    const fileName = 'idempotency-test.md';
    const fileContent = '# Idempotency Test\n\nOriginal content.\n';
    await page.setInputFiles('input[type="file"]', {
      name: fileName,
      mimeType: 'text/markdown',
      buffer: Buffer.from(fileContent)
    });

    await page.getByRole('button', { name: 'Upload & Ingest' }).click();
    const sourceCard = page.locator('.rounded-xl', { hasText: fileName }).first();
    await expect(sourceCard).toContainText('completed', { timeout: 60000 });

    // 2. Count initial chunks
    await sourceCard.getByRole('button', { name: 'View Details' }).click();
    await expect(page.getByRole('heading', { name: 'Source Details' })).toBeVisible();
    
    // Wait for chunks to be rendered
    const chunkLocator = page.locator('.md\\:col-span-2 .rounded-lg.border');
    await expect(chunkLocator.first()).toBeVisible({ timeout: 10000 });
    const initialChunks = await chunkLocator.count();
    expect(initialChunks).toBeGreaterThan(0);

    // 3. Trigger Re-sync
    await page.goto('/'); // Back to list
    const resyncBtn = page.locator('.rounded-xl', { hasText: fileName }).first().getByTitle('Re-sync');
    await resyncBtn.click();
    
    // Wait for it to transition back to completed
    // It should go from completed -> in_progress -> completed
    await expect(sourceCard).toContainText('completed', { timeout: 60000 });

    // 4. Verify chunk count is same
    await sourceCard.getByRole('button', { name: 'View Details' }).click();
    await expect(page.getByRole('heading', { name: 'Source Details' })).toBeVisible();
    
    // Wait for chunks to be rendered
    await expect(chunkLocator.first()).toBeVisible();
    const finalChunks = await chunkLocator.count();
    expect(finalChunks).toBe(initialChunks);
  });
});
