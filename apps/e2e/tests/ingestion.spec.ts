import { test, expect } from '@playwright/test';
import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';

test.describe('Document Ingestion', () => {
  test('should upload and ingest a markdown file successfully', async ({ page }) => {
    // 1. Navigate to home
    await page.goto('/');
    await expect(page).toHaveTitle(/Qurio/);

    // 2. Click File Upload Tab
    await page.getByRole('button', { name: 'File Upload' }).click();
    await expect(page.getByText('Select Document')).toBeVisible();

    // 3. Upload File
    // Create a virtual file for the test
    const timestamp = Date.now();
    const fileName = `e2e-test-${timestamp}.md`;
    const fileContent = `# Automated Test Doc ${timestamp}\n\nThis is a test document created by Playwright e2e tests.\n`;
    await page.setInputFiles('input[type="file"]', {
      name: fileName,
      mimeType: 'text/markdown',
      buffer: Buffer.from(fileContent)
    });

    // 4. Click Upload & Ingest
    const uploadBtn = page.getByRole('button', { name: 'Upload & Ingest' });
    await expect(uploadBtn).toBeEnabled();
    await uploadBtn.click();

    // 5. Verify Status Transition
    // It might start as pending/in_progress, wait for completed
    // We look for a badge within a card that contains our filename
    const sourceCard = page.locator('.rounded-xl', { hasText: fileName }).first();
    
    // Wait for the status badge to say 'completed'
    // Increase timeout because ingestion might take a moment
    await expect(sourceCard).toContainText('completed', { timeout: 90000 });

    // 6. Verify Details Page
    await sourceCard.getByRole('button', { name: 'View Details' }).click();
    
    // Verify we are on details page
    await expect(page.getByRole('heading', { name: 'Source Details' })).toBeVisible();
    // Use more specific locator to avoid strict mode violation (matches both header and chunk list)
    await expect(page.locator(`h1:has-text("Source Details") + p:has-text("${fileName}")`)).toBeVisible();
    
    // Verify chunks content matches what we uploaded
    await expect(page.getByText(`# Automated Test Doc ${timestamp}`)).toBeVisible();
  });

  test('should upload and ingest a PDF file successfully', async ({ page }) => {
    // 1. Generate Valid PDF
    const timestamp = Date.now();
    const pdfDoc = await PDFDocument.create();
    const timesRomanFont = await pdfDoc.embedFont(StandardFonts.TimesRoman);
    const page1 = pdfDoc.addPage();
    const { width, height } = page1.getSize();
    page1.drawText(`This is a test PDF generated by Playwright at ${timestamp}.`, {
      x: 50,
      y: height - 4 * 50,
      size: 30,
      font: timesRomanFont,
      color: rgb(0, 0.53, 0.71),
    });
    const pdfBytes = await pdfDoc.save();

    // 2. Navigate to home
    await page.goto('/');

    // 3. Click File Upload Tab
    await page.getByRole('button', { name: 'File Upload' }).click();

    // 4. Upload File
    // const timestamp used from above
    const fileName = `e2e-test-${timestamp}.pdf`;
    await page.setInputFiles('input[type="file"]', {
      name: fileName,
      mimeType: 'application/pdf',
      buffer: Buffer.from(pdfBytes)
    });

    // 5. Click Upload & Ingest
    const uploadBtn = page.getByRole('button', { name: 'Upload & Ingest' });
    await expect(uploadBtn).toBeEnabled();
    await uploadBtn.click();

    // 6. Verify Status Transition
    const sourceCard = page.locator('.rounded-xl', { hasText: fileName }).first();
    await expect(sourceCard).toContainText('completed', { timeout: 300000 }); // Longer timeout for PDF processing

    // 7. Verify Details Page
    await sourceCard.getByRole('button', { name: 'View Details' }).click();
    
    // Verify chunk content (Docling should extract the text)
    await expect(page.getByText('This is a test PDF generated by Playwright')).toBeVisible({ timeout: 10000 });

    // Verify metadata extraction if exposed in UI
    // Note: The UI might not show metadata yet, but we can check if the API returns it
    const response = await page.request.get(`/api/sources/${(await sourceCard.getAttribute('data-id')) || ''}`);
    // Ideally we would check the response body, but Playwright tests UI mostly. 
    // Assuming if text is visible, ingestion worked.
  });

  test('re-ingestion should replace chunks (idempotency)', async ({ page }) => {
    // 1. Ingest a file
    await page.goto('/');
    await page.getByRole('button', { name: 'File Upload' }).click();
    
    const timestamp = Date.now();
    const fileName = `idempotency-test-${timestamp}.md`;
    const fileContent = `# Idempotency Test ${timestamp}\n\nOriginal content.\n`;
    await page.setInputFiles('input[type="file"]', {
      name: fileName,
      mimeType: 'text/markdown',
      buffer: Buffer.from(fileContent)
    });

    await page.getByRole('button', { name: 'Upload & Ingest' }).click();
    const sourceCard = page.locator('.rounded-xl', { hasText: fileName }).first();
    await expect(sourceCard).toContainText('completed', { timeout: 120000 });

    // 2. Count initial chunks
    await sourceCard.getByRole('button', { name: 'View Details' }).click();
    await expect(page.getByRole('heading', { name: 'Source Details' })).toBeVisible();
    
    // Wait for chunks to be rendered
    const chunkLocator = page.locator('.md\\:col-span-2 .rounded-lg.border');
    await expect(chunkLocator.first()).toBeVisible({ timeout: 10000 });
    const initialChunks = await chunkLocator.count();
    expect(initialChunks).toBeGreaterThan(0);

    // 3. Trigger Re-sync
    await page.goto('/'); // Back to list
    const resyncBtn = page.locator('.rounded-xl', { hasText: fileName }).first().getByTitle('Re-sync');
    
    // Wait for the API call to ensure the action is registered
    const resyncResponsePromise = page.waitForResponse(response => 
      response.url().includes('/resync') && response.request().method() === 'POST'
    );
    await resyncBtn.click();
    await resyncResponsePromise;
    
    // 4. Verify chunk count is same
    await sourceCard.getByRole('button', { name: 'View Details' }).click();
    await expect(page.getByRole('heading', { name: 'Source Details' })).toBeVisible();
    
    // Poll for chunks by reloading until they appear
    // The initial fetch might return 0 chunks if processing is in progress
    await expect(async () => {
        await page.reload();
        await expect(page.getByRole('heading', { name: 'Source Details' })).toBeVisible();
        await expect(chunkLocator.first()).toBeVisible({ timeout: 2000 });
    }).toPass({ timeout: 60000, intervals: [2000] });

    const finalChunks = await chunkLocator.count();
    expect(finalChunks).toBe(initialChunks);
  });
});
