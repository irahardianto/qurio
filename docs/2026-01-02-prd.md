# Product Requirements Document: Qurio Capabilities Enhancement
**Date:** 2026-01-02
**Status:** Draft
**Context:** Improving ingestion quality, retrieval precision, and agent capabilities for software engineering documentation.

## 1. Executive Summary
This initiative aims to upgrade Qurio from a generic RAG system to a specialized Software Engineering knowledge base. Key improvements include code-aware ingestion, metadata-based filtering for precise retrieval (separating code from prose), and context-enriched embeddings. Additionally, we will standardize tool naming and introduce a new mechanism for fetching full documents.

## 2. Features & Requirements

### 2.1 Improved Ingestion & Chunking
**Goal:** Preserve the semantic structure of code and documentation during ingestion.
-   **Markdown-Aware Chunking:** Replace naive word-based splitting with a logic that respects Markdown headers.
-   **Code Block Integrity (CRITICAL):**
    -   Code blocks fenced with backticks (```) **MUST NEVER be split** into multiple chunks.
    -   The integrity of the code syntax must be preserved.
    -   *Exception:* If a single code block exceeds the maximum token limit for the embedding model, it must be split by line (preserving indentation), not by word/token.
-   **Content Type Detection:** Automatically classify chunks into distinct types during ingestion:
    -   `prose`: General text, explanations.
    -   `code`: Implementation logic, functions.
    -   `api`: Endpoint definitions, schemas.
    -   `cmd`: CLI commands, terminal output.
    -   `config`: Configuration files (YAML, JSON).
-   **Metadata Extraction:** Extract `language` (e.g., go, python) from code fences.

### 2.2 Contextual Embeddings
**Goal:** Eliminate ambiguity in isolated chunks by injecting document-level context.
-   **Strategy:** Embed a composite string while storing the original raw text for display.
-   **Embedding Format:**
    ```text
    Title: <Page Title>
    Source: <Source Name>
    Path: <Breadcrumbs>
    Type: <Content Type>
    ---
    <Raw Chunk Content>
    ```

### 2.3 Metadata-Based Filtering
**Goal:** Allow agents to explicitly query for specific types of content (e.g., "just the code").
-   **Data Model:** Add `type`, `language`, and `title` fields to the Weaviate `DocumentChunk` schema.
-   **Retrieval Logic:** Update `search` to support a `filter` object that maps to Weaviate `where` clauses.

### 2.4 Agent Tooling Upgrades & Experience (AX)
**Goal:** Transform tools from passive functions into "Active Instructions" that guide the agent toward success.

#### **Renamed Tool: `qurio_search`**
-   **Design Philosophy:** The tool description serves as a mini-manual for the agent, reducing hallucination and improving query formulation.
-   **Enhanced Description:**
    > "Search the specialized software engineering knowledge base. Use this tool effectively by matching your query intent to the available filters.
    >
    > **STRATEGY GUIDE:**
    > 1. **Finding Implementation:** If you need code snippets, functions, or classes, YOU MUST set `filter.type='code'`.
    > 2. **Understanding Concepts:** If you need high-level explanations or architecture, set `filter.type='prose'`.
    > 3. **API/Configuration:** Use 'api' for endpoints and 'config' for YAML/JSON setups.
    > 4. **Precision:** Use `alpha=0.0` (Keyword) for specific error codes (e.g., '0x8004'), IDs, or function names.
    > 5. **Discovery:** Use `alpha=0.7` (Semantic) for broad questions like 'how to handle auth'.
    >
    > **EXAMPLES:**
    > - *User:* 'Show me the Go code for the login handler.' -> `query='login handler', filter={'type': 'code', 'language': 'go'}, alpha=0.5`
    > - *User:* 'What is the retry policy configuration?' -> `query='retry policy', filter={'type': 'config'}, alpha=0.7`
    > - *User:* 'Explain how the crawler works.' -> `query='crawler architecture', filter={'type': 'prose'}, alpha=0.8`
    >
    > **Returns:** A list of relevant text chunks with metadata. If results are cut off, use `qurio_fetch_page` with the returned URL."
-   **Arguments:**
    ```json
    {
      "query": "string (Required)",
      "filter": {
        "type": "object",
        "properties": {
          "type": { "enum": ["code", "api", "cmd", "config", "prose"] },
          "language": { "type": "string", "description": "Target language (e.g. 'go', 'python')" }
        }
      },
      "alpha": "number (0.0 to 1.0)"
    }
    ```

#### **New Tool: `qurio_fetch_page`**
-   **Design Philosophy:** The "Deep Dive" mechanism. Prevents the agent from guessing content between chunks.
-   **Enhanced Description:**
    > "Retrieve the COMPLETE content of a document by its URL.
    >
    > **WHEN TO USE:**
    > - A `qurio_search` result looks promising but is truncated or missing context.
    > - You need to analyze an entire file, class, or chapter to answer the user's question.
    > - The user asks to 'read' or 'summarize' a specific page found in search results.
    >
    > **BEHAVIOR:**
    > - Stitches together all chunks associated with the URL in their original order.
    > - Returns the full Markdown text."
-   **Arguments:**
    ```json
    {
      "url": "string (Required: Must be an exact URL returned from a previous search result)"
    }
    ```

## 3. Functional Requirements

### 3.1 Data Ingestion
*   **FR-01:** The system MUST identify and extract the title of the processed page.
*   **FR-02:** The system MUST classify each chunk into one of the following types: `prose`, `code`, `api`, `cmd`, `config`.
*   **FR-03:** The chunker MUST NOT split code blocks unless they strictly exceed the embedding model's token limit.
*   **FR-04:** If a code block is split, the system MUST strictly adhere to line-based splitting to prevent syntax corruption.
*   **FR-05:** The system MUST extract the programming language specified in markdown code fences (e.g., ```go -> "go").

### 3.2 Embedding & Storage
*   **FR-06:** The embedding process MUST prepend a context header (Title, URL, Type) to the chunk content before vectorization.
*   **FR-07:** The system MUST store the `title`, `type`, and `language` as filterable metadata properties in the vector database.
*   **FR-08:** The stored "display content" MUST be the original, unmodified chunk text (without the injected context header).

### 3.3 Retrieval & Tools
*   **FR-09:** The `qurio_search` tool MUST accept optional `type` and `language` filters.
*   **FR-10:** The `qurio_search` tool MUST apply these filters as strict `where` clauses in the vector database query.
*   **FR-11:** The `qurio_fetch_page` tool MUST return the full text of a document by concatenating all chunks associated with a given URL, sorted by `chunkIndex`.
*   **FR-12:** All MCP tools MUST use the `qurio_` prefix to avoid collision and ensure standard naming.
*   **FR-13:** The tool descriptions MUST include usage strategies and **concrete examples of different query variations** to guide the AI agent.

## 4. Technical Implementation Plan

### 4.1 Backend (Go)
-   **`internal/text/chunker.go`**: Implement `MarkdownChunker` struct/interface.
-   **`internal/adapter/weaviate/store.go`**: Update `StoreChunk` (new properties) and `Search` (filtering logic).
-   **`internal/retrieval/service.go`**: Update `SearchOptions` to include filters.
-   **`features/mcp/handler.go`**:
    -   Rename `search` -> `qurio_search`.
    -   Implement `qurio_fetch_page` handler.
    -   **Update Tool Definitions:** Apply the enhanced descriptions (including examples) AND update the `inputSchema` to support the new `filter` object structure.

### 4.2 Ingestion Worker (Python)
-   **`handlers/web.py`**: Update extraction logic to capture `title` and pass it in the payload.

### 4.3 Database
-   **Weaviate Schema**: No migration needed (Weaviate is schema-less/auto-schema), but we will start sending new properties immediately.

## 5. Success Metrics
-   **Precision:** An agent query for "code" should return >80% code chunks.
-   **Context:** Search results for generic terms (e.g., "config") should prioritize chunks with relevant titles/paths via contextual embedding.
-   **Usability:** The agent successfully uses `qurio_fetch_page` when it needs more context.